require("builder")

module MojoDNA::Searchable::Solr
  class ConfigGenerator
    def self.create(klass)
      doc = ""
      xml = Builder::XmlMarkup.new(:target => doc, :indent => 2)
      xml.instruct!
      xml.comment!("SOLR schema.xml generated by Searchable.")
      xml.comment!("schema.xml documentation: http://wiki.apache.org/solr/SchemaXml")
      xml.comment!("Searchable: http://mojodna.net/searchable/ruby/")
      xml.schema(:name => klass.to_s, :version => "1.1") do
        xml.types do
          xml.fieldtype(:name => "string",  :class => "solr.StrField", :sortMissingLast => "true")
          xml.fieldtype(:name => "boolean", :class => "solr.BoolField", :sortMissingLast => "true")
          xml.fieldtype(:name => "integer", :class => "solr.IntField")
          xml.fieldtype(:name => "long",    :class => "solr.LongField")
          xml.fieldtype(:name => "float",   :class => "solr.FloatField")
          xml.fieldtype(:name => "double",  :class => "solr.DoubleField")
          xml.fieldtype(:name => "sint",    :class => "solr.SortableIntField", :sortMissingLast => "true")
          xml.fieldtype(:name => "slong",   :class => "solr.SortableLongField", :sortMissingLast => "true")
          xml.fieldtype(:name => "sfloat",  :class => "solr.SortableFloatField", :sortMissingLast => "true")
          xml.fieldtype(:name => "sdouble", :class => "solr.SortableDoubleField", :sortMissingLast => "true")
          xml.fieldtype(:name => "date",    :class => "solr.DateField", :sortMissingLast => "true")
          xml.fieldtype(:name => "datetime",:class => "solr.DateField", :sortMissingLast => "true")
          xml.fieldtype(:name => "text_lu", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.StandardTokenizerFactory")
              xml.filter(:class => "solr.StandardFilterFactory")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.StopFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end
          xml.fieldtype(:name  => "text_ws", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
            end
          end
          xml.fieldtype(:name  => "text", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer(:type => "index") do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "1",  :generateNumberParts => "1", :catenateWords => "1", :catenateNumbers => "1", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
            xml.analyzer(:type => "query") do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.SynonymFilterFactory", :synonyms => "synonyms.txt", :ignoreCase => "true", :expand => "true")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "1", :generateNumberParts => "1", :catenateWords => "0", :catenateNumbers => "0", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end
          xml.fieldtype(:name  => "textTight", :class => "solr.TextField", :positionIncrementGap => "100") do
            xml.analyzer do
              xml.tokenizer(:class => "solr.WhitespaceTokenizerFactory")
              xml.filter(:class => "solr.SynonymFilterFactory", :synonyms => "synonyms.txt", :ignoreCase => "true", :expand => "false")
              xml.filter(:class => "solr.StopFilterFactory", :ignoreCase => "true")
              xml.filter(:class => "solr.WordDelimiterFilterFactory", :generateWordParts => "0", :generateNumberParts => "0", :catenateWords => "1", :catenateNumbers => "1", :catenateAll => "0")
              xml.filter(:class => "solr.LowerCaseFilterFactory")
              xml.filter(:class => "solr.EnglishPorterFilterFactory", :protected => "protwords.txt")
              # xml.filter(:class => "solr.RemoveDuplicatesTokenFilterFactory")
            end
          end
        end
        
        xml.fields do
          xml.comment!("Core fields")
          xml.field(:name => "_id",      :type => "integer", :indexed => "true", :stored => "true")
          xml.field(:name => "_type",    :type => "string",  :indexed => "true", :stored => "true")
          xml.field(:name => "_type-id", :type => "string",  :indexed => "true", :stored => "true")
          xml.field(:name => "_text",    :type => "text",    :indexed => "true", :stored => "false", :multiValued => "true")
          
          if klass.searchable_fields
            xml.comment!("Generated fields")
            klass.searchable_fields.values.each do |field|
              make_fields(xml, field)
            end
          else
            # no columns were specified, so default to all (excluding relations)
            xml.comment!("Default columns")
            klass.content_columns.each do |column|
              xml.field(:name => column.name, :type => (column.type == :string ? :text : column.type).to_s, :indexed => "true", :stored => "false", :multiValued => "true")
            end
          end
          
          xml.comment!("Dynamic field mappings for use in to_search_fields")
          xml.dynamicField(:name => "*_i",  :type => "sint",    :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_s",  :type => "string",  :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_l",  :type => "slong",   :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_t",  :type => "text",    :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_b",  :type => "boolean", :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_f",  :type => "sfloat",  :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_d",  :type => "sdouble", :indexed => "true", :stored => "true")
          xml.dynamicField(:name => "*_dt", :type => "date",    :indexed => "true", :stored => "true")
          
          xml.comment!("Handle active record id fields")
          xml.dynamicField(:name => "*_id", :type => "integer", :indexed => "true", :stored => "true", :multiValued => "true")
          xml.comment!("Wildcard to handle all other fields")
          xml.dynamicField(:name => "*", :type => "text", :indexed => "true", :stored => "false", :multiValued => "true")
        end
        
        xml.comment!("Unique key for inserts/updates")
        xml.uniqueKey("_type-id")
        xml.defaultSearchField("_text")

        xml.comment!("Default fields")
        klass.field_names.each do |f|
          xml.copyField(:source => f, :dest => "_text")
        end
      end
      
      doc
    end
    
    def self.make_fields(xml, field, stack = [] )
      # create basic field
      xml.field(:name => [stack + [field.indexed_name]].join("."), :type => (field.tokenized? ? "text" : "string"), :indexed => "true", :stored => field.stored?.to_s, :multiValued => "true") if field.include.empty?
      
      # create all appropriate subfields
      field.include.values.each do |subfield|
        make_fields( xml, subfield, [stack + [field.indexed_name]] )
      end
      
      # create aliases
      field.aliases.each do |a|
        xml.field(:name => [stack + [a]].join("."), :type => (field.tokenized? ? "text" : "string"), :indexed => "true", :stored => field.stored?.to_s, :multiValued => "true") if field.include.empty?

        # create subfields for aliases
        field.include.values.each do |subfield|
          make_fields( xml, subfield, [stack + [a]] )
        end
      end
      
      # create sortable field
      xml.field(:name => "_sort-#{field.indexed_name}", :type => "string", :indexed => "false", :stored => true, :multiValued => "true") if field.sortable?

      xml
    end
  end
end
